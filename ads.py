# -*- coding: utf-8 -*-
"""ADS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wgatu1kYeY7ZX2CC9cVNvxBNk9nWQc-5
"""

class Heap:
    def __init__(self):
        self.heap = []

    def heap_size(self):
        return len(self.heap)  # current number of elements in the heap

    def swap(self, i, j):
        temp = self.heap[i]
        self.heap[i] = self.heap[j]
        self.heap[j] = temp

    def swap(self, i, j):
        temp = self.heap[i]                         # store first element
        self.heap[i] = self.heap[j]                 # move second into first
        self.heap[j] = temp                         # move temp into second

    def insert(self, item):
        self.heap.append(item)                      # add new item at the end
        self.fix_up(self.heap_size() - 1)           # restore heap property going up

    def fix_up(self, index):
        parent_index = (index - 1) // 2             # parent of current index

        if index > 0 and self.heap[index][0] > self.heap[parent_index][0]:
            self.swap(index, parent_index)          # swap with parent if child is larger
            self.fix_up(parent_index)               # continue fixing up

    def get_max(self):
        if self.heap_size() == 0:
            return None                             # heap empty
        return self.heap[0]                         # root is max element

    def pop_max(self):
        if self.heap_size() == 0:
            return None                             # nothing to remove

        max_item = self.heap[0]                     # save max element
        last_index = self.heap_size() - 1
        self.swap(0, last_index)                    # move last element to root
        self.heap.pop()                             # remove last position

        if self.heap_size() > 0:
            self.fix_down(0)                        # restore heap property going down

        return max_item                             # return max element

    def fix_down(self, index):
        left = 2 * index + 1                        # left student index
        right = 2 * index + 2                       # right student index
        largest = index                             # assume current is largest

        if left < self.heap_size() and self.heap[left][0] > self.heap[largest][0]:
            largest = left                          # left student is larger

        if right < self.heap_size() and self.heap[right][0] > self.heap[largest][0]:
            largest = right                         # right student is larger

        if largest != index:
            self.swap(index, largest)               # swap with larger student
            self.fix_down(largest)                  # continue fixing down

def create_user(users):
    print("\nLet's create your StudyLink profile!")                         # explanation to user

    username = input("Enter your username: ").strip().lower()              # ask for username
    while username in users:
        print("This username already exists, choose another one.")         # check duplicates
        username = input("Enter your username: ").strip().lower()

    degree = input("Enter your degree (e.g. BBA, BBABDA, LLB): ").strip().lower()   # degree

    campus = input("Enter your campus (Madrid/Segovia): ").strip().lower()          # campus
    while campus not in ["madrid", "segovia"]:
        print("Invalid campus.")                                                     # campus check
        campus = input("Enter your campus (Madrid/Segovia): ").strip().lower()

    # classes input
    classes = input("Enter your classes separated by commas: ").strip().lower()      # classes
    class_set = set(c.strip() for c in classes.split(","))                           # convert to set

    # availability input
    availability = input("Enter your availability (e.g. mon-10, wed-16) separated by commas: ").strip().lower()
    avail_set = set(a.strip() for a in availability.split(","))                      # convert to set

    # preferences input
    preferences = input("Enter your study preferences separated by commas (e.g. quiet, discussion, willing_to_tutor): ").strip().lower()
    pref_set = set(p.strip() for p in preferences.split(","))                        # convert to set

    # store all info into dictionary
    users[username] = [
        degree,                                                                       # degree
        campus,                                                                       # campus
        class_set,                                                                    # set of classes
        avail_set,                                                                    # set of availability
        pref_set                                                                      # set of preferences
    ]

    print("\nProfile created successfully!\n")                                        # confirmation

def compute_score(users, user1, user2):
    data1 = users[user1]                               # data for first user
    data2 = users[user2]                               # data for second user

    degree1, campus1, classes1, avail1, prefs1 = data1 # unpack first user
    degree2, campus2, classes2, avail2, prefs2 = data2 # unpack second user

    shared_classes = len(classes1 & classes2)          # number of common classes
    shared_slots = len(avail1 & avail2)                # number of common time slots
    shared_prefs = len(prefs1 & prefs2)                # number of common preferences

    score = 0                                          # start score from 0

    score += 5 * shared_classes                        # classes are most important
    score += 3 * shared_slots                          # time overlap matters
    if campus1 == campus2:
        score += 4                                     # same campus adds points
    score += 2 * shared_prefs                          # similar preferences small bonus

    return score                                       # final compatibility score

def build_matches_heap(users, current_user):
    heap = Heap()                                      # create empty heap

    for other_user in users:                           # go through all users
        if other_user == current_user:                 # skip same user
            continue

        score = compute_score(users, current_user, other_user)  # compute compatibility

        if score > 0:                                  # only keep positive matches
            heap.insert((score, other_user))           # insert (score, username) in heap

    return heap                                        # return heap with matches

def show_best_matches(users):
    print("\nAvailable users in the system:")          # list all usernames
    for name in users.keys():
        print("-", name)

    current_user = input("\nEnter your username to see your best study matches: ").strip().lower()

    while current_user not in users:                   # validate username
        print("This username does not exist, please try again.")
        current_user = input("Enter your username: ").strip().lower()

    heap = build_matches_heap(users, current_user)     # build heap of matches

    if heap.heap_size() == 0:
        print("\nNo compatible matches found yet.\n")  # no matches case
        return

    print("\nThese are your best study matches:\n")    # print top results
    k = 3                                              # number of matches to show
    count = 0

    while count < k and heap.heap_size() > 0:
        score, name = heap.pop_max()                   # get best match
        print("Match:", name, "- score:", score)       # show match and score
        count += 1
    print()

def main():
    users = {}                                   # empty dictionary

    while True:
        print("1) Create user")
        print("2) Show matches")
        print("3) Quit")
        choice = input("Choose an option: ").strip()

        if choice == "1":
            create_user(users)
        elif choice == "2":
            if len(users) == 0:
                print("No users in the system yet.")
            else:
                show_best_matches(users)
        elif choice == "3":
            print("Goodbye!")
            break
        else:
            print("Invalid option, try again.")

main()
